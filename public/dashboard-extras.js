// Additional dashboard functionality
document.addEventListener('DOMContentLoaded', () => {
    // --- Notification Logic ---
    const userIconBadge = document.getElementById('user-icon-notification-badge');
    const dropdownBadge = document.getElementById('dropdown-notification-badge');
    const notificationMenuButton = document.getElementById('notification-menu-button');
    const addNotificationButton = document.getElementById('add-notification-button');
    
    // Modal Elements
    const notificationModal = document.getElementById('notification-modal');
    const notificationList = document.getElementById('notification-list');
    const closeNotificationModalButton = document.getElementById('close-notification-modal');
    const notificationModalOverlay = document.getElementById('notification-modal-overlay');
    const modalHeaderBadge = document.getElementById('modal-header-notification-badge');
    const modalTitle = document.getElementById('notification-modal-title');
    const historyButton = document.getElementById('history-button');
    const clearAllButton = document.getElementById('clear-all-button');
    const backButton = document.getElementById('back-button');

    // --- Notification State ---
    let isHistoryView = false;
    let notificationHistory = [];
    
    // Demo notifications data
    let notifications = [
        // Today
        { id: 1, text: "Your profile analysis is complete. View your new insights.", timestamp: "5 mins ago", read: false, sourceId: 'brand-intelligence', createdAt: new Date('2025-09-20T09:35:00Z').getTime() },
        { id: 2, text: "Your brand score improved by 5 points!", timestamp: "50 mins ago", read: false, sourceId: 'brand-audit', createdAt: new Date('2025-09-20T08:50:00Z').getTime() },
        { id: 3, text: "New feature 'AI Portfolio' is now available.", timestamp: "2 hours ago", read: false, sourceId: 'career-portfolio', createdAt: new Date('2025-09-20T07:50:00Z').getTime() },
        { id: 4, text: "You have 3 new job recommendations.", timestamp: "5 hours ago", read: false, sourceId: 'job-finder', createdAt: new Date('2025-09-20T04:50:00Z').getTime() },
        
        // Yesterday
        { id: 5, text: "You have a new connection request from Jane Doe.", timestamp: "Yesterday", read: true, sourceId: 'event-scout', createdAt: new Date('2025-09-19T18:00:00Z').getTime() },
        { id: 6, text: "Monthly Brand Review is ready.", timestamp: "Yesterday", read: true, sourceId: 'brand-audit', createdAt: new Date('2025-09-19T12:00:00Z').getTime() },

        // This Week
        { id: 7, text: "A new post was generated for your review.", timestamp: "Wednesday", read: true, sourceId: 'content-engine', createdAt: new Date('2025-09-17T10:00:00Z').getTime() },
        { id: 8, text: "3 new articles have been generated by the Content Engine.", timestamp: "Tuesday", read: true, sourceId: 'content-engine', createdAt: new Date('2025-09-16T14:00:00Z').getTime() },
        
        // Previously (This Month / Older)
        { id: 9, text: "A new skill 'Data Analysis' was added to your Skill Radar.", timestamp: "Sep 5", read: true, sourceId: 'skill-radar', createdAt: new Date('2025-09-05T09:00:00Z').getTime() },
        { id: 10, text: "Your 'Content Engine' summary from last month.", timestamp: "Last month", read: true, sourceId: 'content-engine', createdAt: new Date('2025-08-15T12:00:00Z').getTime() },
        { id: 11, text: "Older notification from a while back.", timestamp: "2 months ago", read: true, sourceId: 'dashboard', createdAt: new Date('2025-07-10T12:00:00Z').getTime() },
    ];
    
    function filterOldNotifications() {
        // Automatically remove notifications older than 30 days from active list
        const thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000);
        notifications = notifications.filter(n => n.createdAt >= thirtyDaysAgo);
         // We could also clean up the history here if needed, but the prompt implies they persist.
    }
    
    function getNotificationCategory(timestamp) {
        const now = new Date('2025-09-20T09:10:00'); // Fixed time for consistent demo
        const date = new Date(timestamp);
        
        const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        const yesterday = new Date(today);
        yesterday.setDate(yesterday.getDate() - 1);
        const notificationDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());

        if (notificationDate.getTime() === today.getTime()) return 'Today';
        if (notificationDate.getTime() === yesterday.getTime()) return 'Yesterday';
        
        const startOfWeek = new Date(today);
        startOfWeek.setDate(today.getDate() - today.getDay()); 
        if (notificationDate >= startOfWeek) return 'This Week';

        const startOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
        if (notificationDate >= startOfMonth) return 'This Month';

        return 'Older';
    }

    function renderNotifications() {
        const listToRender = isHistoryView ? notificationHistory : notifications;
        notificationList.innerHTML = '';
        
        if (listToRender.length === 0) {
            const message = isHistoryView ? "Your notification history is empty." : "You're all caught up!";
            notificationList.innerHTML = `<li class="text-center text-slate-500 dark:text-slate-400 py-12">${message}</li>`;
            return;
        }

        const grouped = listToRender.reduce((acc, n) => {
            const category = getNotificationCategory(n.createdAt);
            if (!acc[category]) acc[category] = [];
            acc[category].push(n);
            return acc;
        }, {});

        const categoryOrder = ['Today', 'Yesterday', 'This Week', 'This Month', 'Older'];
        
        categoryOrder.forEach(category => {
            if (grouped[category]) {
                const header = document.createElement('li');
                // Add a specific class to target these headers with CSS
                header.className = 'notification-category-header';
                // The H4 inside no longer needs a background as it scrolls with content.
                header.innerHTML = `<h4 class="text-sm font-bold text-slate-500 dark:text-slate-400 py-2">${category}</h4>`;
                notificationList.appendChild(header);

                grouped[category].forEach(notification => {
                    const li = document.createElement('li');
                    const isClickable = !isHistoryView;
                    li.className = `flex items-start gap-4 p-4 rounded-xl transition-colors ${isClickable ? 'cursor-pointer bg-slate-50 border border-slate-200 hover:bg-slate-100 dark:hover:bg-slate-700' : 'bg-slate-50/50 dark:bg-slate-800/50'}`;
                    li.dataset.id = notification.id;

                    let iconHtml = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5 text-indigo-600"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>';
                    const sourceLink = document.querySelector(`.sidebar-link[data-id="${notification.sourceId}"]`);
                    if (sourceLink) {
                        const svgElement = sourceLink.querySelector('svg').cloneNode(true);
                        svgElement.classList.remove(...svgElement.classList);
                        svgElement.classList.add('w-5', 'h-5', 'text-indigo-600');
                        iconHtml = svgElement.outerHTML;
                    }

                    let displayTimestampText = notification.timestamp;
                    if (['This Week', 'This Month', 'Older'].includes(category)) {
                        const date = new Date(notification.createdAt);
                        displayTimestampText = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                    }
                    
                    const displayTimestamp = `<span class="font-medium" style="color: #4f46e5;">${displayTimestampText}</span>`;

                    li.innerHTML = `
                        <div class="flex-shrink-0 w-12 h-12 rounded-full bg-white flex items-center justify-center shadow-md">${iconHtml}</div>
                        <div class="flex-grow">
                            <div class="flex items-start justify-between">
                                <p class="text-sm font-medium text-slate-800 dark:text-slate-200 pr-2">${notification.text}</p>
                                ${!isHistoryView && !notification.read ? '<span class="flex-shrink-0 text-xs font-medium px-2 py-1 rounded-full bg-indigo-600 text-white">New</span>' : ''}
                            </div>
                            <p class="text-xs mt-1">${displayTimestamp}</p>
                        </div>
                    `;
                    
                    if (isClickable) {
                        li.addEventListener('click', () => {
                            const notif = notifications.find(n => n.id == notification.id);
                            if (notif) {
                                // Mark as read if it was unread
                                if (!notif.read) {
                                    notif.read = true;
                                    updateNotificationUI(); // Update the badges
                                }

                                // Find the corresponding sidebar link and click it to navigate
                                const sourceLink = document.querySelector(`.sidebar-link[data-id="${notif.sourceId}"]`);
                                if (sourceLink) {
                                    sourceLink.click();
                                }
                                
                                // Close the modal for a seamless experience
                                closeModal();
                            }
                        });
                    }
                    notificationList.appendChild(li);
                });
            }
        });
    }

    function updateNotificationUI() {
        const unreadCount = notifications.filter(n => !n.read).length;
        const countStr = unreadCount > 99 ? '99+' : unreadCount.toString();
        if (unreadCount > 0) {
            userIconBadge.textContent = countStr;
            dropdownBadge.textContent = countStr;
            modalHeaderBadge.textContent = countStr;
            userIconBadge.classList.remove('hidden');
            dropdownBadge.classList.remove('hidden');
            modalHeaderBadge.classList.remove('hidden');
        } else {
            userIconBadge.classList.add('hidden');
            dropdownBadge.classList.add('hidden');
            modalHeaderBadge.classList.add('hidden');
        }
    }

    function closeModal() {
        notificationModal.classList.add('hidden');
         // Reset to default view when closing
        if (isHistoryView) {
            isHistoryView = false;
            modalTitle.textContent = 'Notifications';
            historyButton.classList.remove('hidden');
            clearAllButton.classList.remove('hidden');
            backButton.classList.add('hidden');
        }
    }
    
    // Initial UI update
    filterOldNotifications();
    updateNotificationUI();

    // Open modal
    if (notificationMenuButton) {
        notificationMenuButton.addEventListener('click', () => {
            filterOldNotifications();
            renderNotifications();
            notificationModal.classList.remove('hidden');
            userMenu.classList.add('hidden');
        });
    }
    
    // Add a notification for demonstration
    if (addNotificationButton) {
         addNotificationButton.addEventListener('click', () => {
            const newNotification = { id: Date.now(), text: `Brand re-analysis complete! New insights available.`, timestamp: "Just now", read: false, sourceId: 'brand-audit', createdAt: Date.now() };
            notifications.unshift(newNotification);
            updateNotificationUI();
        });
    }

    // Modal event listeners
    closeNotificationModalButton.addEventListener('click', closeModal);
    notificationModalOverlay.addEventListener('click', closeModal);

    clearAllButton.addEventListener('click', () => {
        notificationHistory.unshift(...notifications);
        notifications = [];
        updateNotificationUI();
        renderNotifications();
    });

    historyButton.addEventListener('click', () => {
        isHistoryView = true;
        modalTitle.textContent = 'History';
        historyButton.classList.add('hidden');
        clearAllButton.classList.add('hidden');
        backButton.classList.remove('hidden');
        renderNotifications();
    });
    
    backButton.addEventListener('click', () => {
        isHistoryView = false;
        modalTitle.textContent = 'Notifications';
        historyButton.classList.remove('hidden');
        clearAllButton.classList.remove('hidden');
        backButton.classList.add('hidden');
        renderNotifications();
    });

    // --- Shortcut Customization Logic (with reordering) ---
    const editShortcutsButton = document.getElementById('edit-shortcuts-button');
    const shortcutsContainer = document.getElementById('shortcuts-container');
    let isCustomizing = false;
    let shortcuts = ['brand-audit', 'content-engine', 'job-finder']; // Default shortcuts
    const MAX_SHORTCUTS = 5;
    let draggedShortcutId = null; // To track internal drags

    function handleClickOutsideShortcuts(e) {
        // Deactivate customization if the click is outside the shortcuts container, the sidebar,
        // the user menu itself, and the button that toggles it.
        if (isCustomizing &&
            !shortcutsContainer.contains(e.target) &&
            !sidebar.contains(e.target) &&
            !userMenu.contains(e.target) &&
            !editShortcutsButton.contains(e.target)) {
            toggleCustomizationMode();
        }
    }

    function renderShortcuts() {
        shortcutsContainer.innerHTML = '';

        // Control the placeholder text attribute.
        if (isCustomizing && shortcuts.length === 0) {
            shortcutsContainer.setAttribute('data-placeholder', 'Drag & drop from the sidebar to add shortcuts');
        } else {
            shortcutsContainer.removeAttribute('data-placeholder');
        }

        // Render the actual shortcut items
        shortcuts.forEach(id => {
            const sourceLink = document.querySelector(`.sidebar-link[data-id="${id}"]`);
            if (sourceLink) {
                const shortcutItem = document.createElement('a');
                shortcutItem.href = "#";
                shortcutItem.className = 'shortcut-item';
                shortcutItem.dataset.id = id;
                shortcutItem.setAttribute('draggable', 'true'); // Make shortcuts always draggable
                const iconHTML = sourceLink.querySelector('svg').outerHTML;
                shortcutItem.innerHTML = `${iconHTML}<button class="remove-shortcut-btn">&times;</button>`;
                
                // Add click handler to navigate
                shortcutItem.addEventListener('click', (e) => {
                    if (!isCustomizing) {
                        e.preventDefault();
                        sourceLink.click();
                    }
                });

                // Add remove handler
                shortcutItem.querySelector('.remove-shortcut-btn').addEventListener('click', (e) => {
                     e.preventDefault();
                     e.stopPropagation();
                     shortcuts = shortcuts.filter(sId => sId !== id);
                     renderShortcuts();
                });

                // Add drag handlers for reordering
                shortcutItem.addEventListener('dragstart', (e) => {
                    e.stopPropagation();
                    draggedShortcutId = id;
                    e.dataTransfer.setData('application/shortcut-id', id);
                    e.dataTransfer.effectAllowed = 'move';
                    setTimeout(() => shortcutItem.classList.add('dragging'), 0);
                });

                shortcutItem.addEventListener('dragend', () => {
                    draggedShortcutId = null;
                    shortcutItem.classList.remove('dragging');
                });
                
                shortcutsContainer.appendChild(shortcutItem);
            }
        });
        
        // Render placeholder slots (+) if in customization mode and NOT empty
        if (isCustomizing && shortcuts.length > 0) {
            const emptySlots = MAX_SHORTCUTS - shortcuts.length;
            for (let i = 0; i < emptySlots; i++) {
                const placeholder = document.createElement('div');
                placeholder.className = 'shortcut-placeholder';
                placeholder.textContent = '+';
                shortcutsContainer.appendChild(placeholder);
            }
        }
    }
    
    function toggleCustomizationMode() {
        isCustomizing = !isCustomizing;
        shortcutsContainer.classList.toggle('customization-active', isCustomizing);
        sidebarLinks.forEach(link => {
            link.setAttribute('draggable', isCustomizing);
        });
        
        const buttonSpan = editShortcutsButton.querySelector('span');
        if (isCustomizing) {
            buttonSpan.textContent = 'Done Customizing';
            // Add listener to exit customization by clicking away
            document.addEventListener('click', handleClickOutsideShortcuts, true);
        } else {
            buttonSpan.textContent = 'Customize Shortcuts';
            // Clean up the listener when not customizing
            document.removeEventListener('click', handleClickOutsideShortcuts, true);
        }
        renderShortcuts(); // Re-render to show/hide placeholders
    }

    editShortcutsButton.addEventListener('click', (e) => {
        e.stopPropagation();
        toggleCustomizationMode();
    });
    
    // Drag and Drop Logic from SIDEBAR
    sidebarLinks.forEach(link => {
        link.addEventListener('dragstart', (e) => {
            if(!isCustomizing) {
                e.preventDefault();
                return;
            }
            draggedShortcutId = null; // Ensure we know it's not an internal drag
            e.dataTransfer.setData('application/sidebar-link-id', link.dataset.id);
            link.classList.add('dragging');
        });
        link.addEventListener('dragend', () => {
             link.classList.remove('dragging');
        });
    });

    // Drag handling for the CONTAINER
    shortcutsContainer.addEventListener('dragover', (e) => {
        e.preventDefault();
        // Allow drop if customizing (for new items) or if an internal item is being dragged for reordering
        if (isCustomizing || draggedShortcutId) {
            shortcutsContainer.classList.add('drag-over');
        }
    });

     shortcutsContainer.addEventListener('dragleave', () => {
        shortcutsContainer.classList.remove('drag-over');
    });
    
    shortcutsContainer.addEventListener('drop', (e) => {
        e.preventDefault();
        shortcutsContainer.classList.remove('drag-over');
        
        const newIdFromSidebar = e.dataTransfer.getData('application/sidebar-link-id');
        const movedId = e.dataTransfer.getData('application/shortcut-id');

        // Case 1: Reordering an existing shortcut
        if (movedId) {
            const targetElement = e.target.closest('.shortcut-item');
            if (!targetElement || targetElement.dataset.id === movedId) {
                return; // Dropped on itself or in a gap, do nothing
            }

            const fromIndex = shortcuts.indexOf(movedId);
            const toIndex = shortcuts.indexOf(targetElement.dataset.id);

            if (fromIndex !== -1 && toIndex !== -1) {
                // Move element in the array
                const [item] = shortcuts.splice(fromIndex, 1);
                shortcuts.splice(toIndex, 0, item);
                renderShortcuts();
            }
        }
        // Case 2: Adding a new shortcut from the sidebar (only in customization mode)
        else if (isCustomizing && newIdFromSidebar) {
            if (!shortcuts.includes(newIdFromSidebar) && shortcuts.length < MAX_SHORTCUTS) {
                const targetElement = e.target.closest('.shortcut-item, .shortcut-placeholder');
                if (targetElement && targetElement.classList.contains('shortcut-item')) {
                    const toIndex = shortcuts.indexOf(targetElement.dataset.id);
                    shortcuts.splice(toIndex, 0, newIdFromSidebar);
                } else {
                    shortcuts.push(newIdFromSidebar);
                }
                renderShortcuts();
            }
        }
    });

    // --- Settings Modal Logic ---
    const settingsButton = document.getElementById('settings-button');
    const settingsModal = document.getElementById('settings-modal');
    const closeSettingsModalButton = document.getElementById('close-settings-modal');
    const settingsModalOverlay = document.getElementById('settings-modal-overlay');
    const cancelSettingsButton = document.getElementById('cancel-settings-button');
    const settingsTabs = document.querySelectorAll('.settings-tab');
    const settingsTabContents = document.querySelectorAll('.settings-tab-content');

    if (settingsButton && settingsModal) {
        settingsButton.addEventListener('click', () => {
            settingsModal.classList.remove('hidden');
            userMenu.classList.add('hidden'); // Close the user menu
        });
    }

    function closeSettingsModal() {
        if (settingsModal) {
            settingsModal.classList.add('hidden');
        }
    }

    if (closeSettingsModalButton) closeSettingsModalButton.addEventListener('click', closeSettingsModal);
    if (settingsModalOverlay) settingsModalOverlay.addEventListener('click', closeSettingsModal);
    if (cancelSettingsButton) cancelSettingsButton.addEventListener('click', closeSettingsModal);

    settingsTabs.forEach(tab => {
        tab.addEventListener('click', (e) => {
            e.preventDefault();
            const tabId = tab.dataset.tab;

            // Update tab styles
            settingsTabs.forEach(t => t.classList.remove('active'));
            tab.classList.add('active');

            // Update content visibility
            settingsTabContents.forEach(content => {
                const contentId = `${tabId}-settings-content`;
                if (content.id === contentId) {
                    content.classList.remove('hidden');
                } else {
                    content.classList.add('hidden');
                }
            });
        });
    });

    // --- NEW Chat Widget Logic ---
    const chatWidgetButton = document.getElementById('chat-widget-button');
    const chatWidget = document.getElementById('chat-widget');
    const closeChatWidgetButton = document.getElementById('close-chat-widget');
    const chatMessages = document.getElementById('chat-messages');
    const chatInput = document.getElementById('chat-input');
    const sendChatButton = document.getElementById('send-chat-button');

    // --- Star Generation for Chat Widget ---
    const starsContainer = document.querySelector('#chat-widget #stars-container');
    if (starsContainer) {
        const numberOfStars = 100;
        const sunRadius = 125; // Half of the sun's 250px width/height
        const minStarRadius = sunRadius + 15; // Start stars just outside the sun
        const maxStarRadius = sunRadius + 120; // How far out the stars should go

        for (let i = 0; i < numberOfStars; i++) {
            const star = document.createElement('div');
            star.className = 'star';
            
            const size = Math.random() * 2 + 1;
            star.style.width = `${size}px`;
            star.style.height = `${size}px`;
            
            // Random position in a circle around the sun's center
            const angle = Math.random() * 2 * Math.PI;
            const radius = Math.random() * (maxStarRadius - minStarRadius) + minStarRadius;
            const xOffset = radius * Math.cos(angle);
            const yOffset = radius * Math.sin(angle);
            
            star.style.left = `calc(50% + ${xOffset}px)`;
            star.style.top = `calc(50% + ${yOffset}px)`;
            
            star.style.animationDuration = `${Math.random() * 3 + 2}s`;
            star.style.animationDelay = `${Math.random() * 3}s`;
            starsContainer.appendChild(star);
        }
    }

    if (chatWidgetButton && chatWidget) {
        chatWidgetButton.addEventListener('click', () => {
            chatWidget.classList.remove('hidden');
            chatWidgetButton.classList.add('hidden');
        });
    }

    if (closeChatWidgetButton) {
        closeChatWidgetButton.addEventListener('click', () => {
            chatWidget.classList.add('hidden');
            chatWidgetButton.classList.remove('hidden');
        });
    }

    function addMessage(message, type) {
        const messageDiv = document.createElement('div');
        messageDiv.className = `chat-message ${type}-message p-3 rounded-lg`;
        messageDiv.innerHTML = `<p class="text-sm">${message}</p>`;
        chatMessages.appendChild(messageDiv);
        // Auto-scroll to bottom
        chatMessages.scrollTop = chatMessages.scrollHeight; 
    }

    function handleSendMessage() {
        const messageText = chatInput.value.trim();
        if (messageText) {
            addMessage(messageText, 'user');
            chatInput.value = '';
            
            // Simulate agent reply
            setTimeout(() => {
                addMessage("Thanks for your message! An agent will be with you shortly.", 'agent');
            }, 1000);
        }
    }

    // Initial agent message
    addMessage("Hello! I am Luna.<br>How can I help you today?", 'agent');

    if (sendChatButton) sendChatButton.addEventListener('click', handleSendMessage);
    if (chatInput) chatInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            handleSendMessage();
        }
    });
});




























